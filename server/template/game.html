<html>

<head>
  <title>Pipopipette</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.1.3/pixi.min.js"></script>
  <style>
    .pixi-container{
      height: 100%
    }
  </style>
</head>

<body>
  <div id="pixi-container" class="pixi-container"></div>
  <script>
    function clamp(x, lower, upper) {
      if (x == NaN || lower == NaN || upper == NaN) {
        return NaN
      }
      return Math.min(Math.max(x, lower), upper)
    }
    
    class SegmentMap {
      constructor() {
        this.data = {}
      }

      set(segment, value) {
        this.data[this._key(segment)] = value
      }
      
      get(segment) {
        return this.data[this._key(segment)]
      }

      foreach(f) {
        for(const key in this.data) {
          f(this._segment(key), this.data[key])
        }
      }

      contains(segment) {
        return this.data.hasOwnProperty(_key(segment))
      }

      _key({x1,y1,x2,y2}) {
        return x1+","+y1+":"+x2+","+y2
      }
      
      _segment(key) {
        const [p1,p2] = key.split(":")
        const [x1,y1] = p1.split(",")
        const [x2,y2] = p2.split(",")
        return {x1: parseInt(x1), y1: parseInt(y1), x2: parseInt(x2), y2: parseInt(y2)}
      }
    }

    const app = new PIXI.Application({
      autoResize: true,
      antialias: true,
      resolution: devicePixelRatio,
    })

    document.querySelector("#pixi-container").appendChild(app.view);

    window.addEventListener('resize', resize);
    console.log(app);

    function GridSegment(segment, color) {
      return {segment, color}
    }

    class Grid extends PIXI.Container {
      constructor(n, debug) {
        super();

        this.n = n;
        this.interactive = true;
        this.highlightedSegment = null;
        this.segments = [];
        this.g = new PIXI.Graphics();

        this.addChild(this.g);
        this.on('pointermove', function(event){
          const mx = event.data.originalEvent.layerX;
          const my = event.data.originalEvent.layerY;
          this.mouse = {x: mx - this.g.x, y: my - this.g.y}
        })

        if (debug) {
          this.gridBound = new PIXI.Graphics();
          this.addChild(this.gridBound);
        }
      }

      setSegments(segments) {
        this.segments = segments;
      }

      onResize(w, h) {
        const pad = 50;
        const sq = Math.min(w, h) - pad;
        const xOff = Math.max(w - sq, 0)/2;
        const yOff = Math.max(h - sq, 0)/2;

        this.g.x = sq/2 + xOff;
        this.g.y = sq/2 + yOff;

        const gridWidth = sq / (this.n-1);
        const radius = gridWidth * 0.08;
        const segmentThickness = gridWidth*0.12;
        
        const dMin = -sq/2 + radius
        const dMax = dMin + sq - 2*radius;

        const step = (dMax-dMin) / (this.n-1);
        
        // save grid parameters
        this.measures = {sq, xOff, yOff, radius, segmentThickness, dMin, dMax, step};

        this.onRender();
      }

      onRender() {
        this.updateHighlightedSegment();

        this.g.clear();
        this.drawHighlightedSegment();
        this.drawSegments();
        this.drawDots();
        this.drawBounds();
      }

      updateHighlightedSegment() {
        if (this.mouse){
          const {x: gx, y: gy} = this.toGrid(this.mouse)
          const ix = Math.floor(gx)
          const iy = Math.floor(gy)
          const rx = gx - ix
          const ry = gy - iy
          let x1,y1,x2,y2
          if (rx < ry && ry > 1 - rx) {          // bottom edge
            x1 = ix
            y1 = iy + 1
            x2 = ix + 1
            y2 = iy + 1
          } else if (rx < ry && ry <= 1 - rx) {  // left edge
            x1 = ix
            y1 = iy
            x2 = ix
            y2 = iy + 1
          } else if (rx >= ry && ry > 1 - rx) {  // right edge
            x1 = ix + 1
            y1 = iy
            x2 = ix + 1
            y2 = iy + 1
          } else if (rx >= ry && ry <= 1 - rx) { // top edge
            x1 = ix 
            y1 = iy
            x2 = ix + 1
            y2 = iy
          }
          x1 = clamp(x1, 0, this.n-1)
          y1 = clamp(y1, 0, this.n-1)
          x2 = clamp(x2, 0, this.n-1)
          y2 = clamp(y2, 0, this.n-1)

          const yOob = iy < 0 || this.n-1 <= iy
          const xOob = ix < 0 || this.n-1 <= ix
          if (yOob && x2 < this.n-1) {
            x2 = x1+1
          } 
          if (xOob && y2 < this.n-1) {
            y2 = y1+1
          }
          if (xOob && yOob) {
            this.highlightedSegment = undefined
            return  
          }

          this.highlightedSegment = {x1, y1, x2, y2}
        }
      }

      drawSegments() {
        this.segments.forEach((s) => {
          this.drawSegment(s.segment, s.color)
        })
      }

      drawHighlightedSegment() {
        if (this.highlightedSegment){
          const {dMin, step} = this.measures;

          this.drawSegment(this.highlightedSegment, 0xFFFFFF)
        }
      }

      drawSegment({x1,y1,x2,y2}, color) {
        const {dMin, step, segmentThickness} = this.measures;
        x1 = dMin + step * x1
        y1 = dMin + step * y1
        x2 = dMin + step * x2
        y2 = dMin + step * y2
        this.g.lineStyle(segmentThickness, color, 1)
        this.g.moveTo(x1,y1)
        this.g.lineTo(x2,y2)
      }

      drawDots() {
        const {dMin, step, radius} = this.measures;
        for (let i = 0; i < this.n; i++) {
          for (let j = 0; j < this.n; j++) {
            let x = dMin + i*step;
            let y = dMin + j*step;
            this.g.beginFill(0xFFFFFF);
            this.g.lineStyle(0, 0xFFFFFF, 0);
            this.g.drawCircle(x,y,radius);
            this.g.endFill()
          }
        }
      }

      drawBounds() {
        if (this.gridBound) {
          const {sq, xOff, yOff} = this.measures;
          this.gridBound.clear()
          this.gridBound.lineStyle(1, 0x00ff00, 1);
          this.gridBound.drawRect(-sq/2, -sq/2, sq, sq);
          
          this.gridBound.x = sq/2 + xOff
          this.gridBound.y = sq/2 + yOff

          this.gridBound.beginFill(0xFFFFFF);
          this.gridBound.drawCircle(0, 0, 1);
        }
      }

      toGrid({x, y}) {
        const {dMin, step} = this.measures;
        return {x: (x - dMin) / step, y: (y - dMin) / step}
      }
    }

    grid = new Grid(20);
    grid.setSegments([
      GridSegment({x1:1,y1:2,x2:2,y2:2}, 0xFF0000),
      GridSegment({x1:4,y1:1,x2:4,y2:2}, 0x0000FF)
    ])
    app.stage.addChild(grid);

    function resize() {
      const parent = app.view.parentNode;
      app.renderer.resize(parent.clientWidth, parent.clientHeight);
      grid.onResize(app.screen.width, app.screen.height);
    }
    resize()

    app.ticker.add(delta => {
      grid.onRender()
    });
  </script>
</body>

</html>